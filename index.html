<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legal Tech Consulting Team Office - Interactive FAQ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        #dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
        }
        
        #dialogue-box h3 {
            margin: 0 0 10px 0;
            color: #1e3a8a;
        }
        
        #dialogue-content {
            margin: 10px 0;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .dialogue-option {
            background: #f0f0f0;
            border: 2px solid #1e3a8a;
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .dialogue-option:hover {
            background: #1e3a8a;
            color: white;
            transform: translateX(5px);
        }
        
        #custom-question-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        #custom-question-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #1e3a8a;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
        }
        
        #custom-question-submit {
            background: #1e3a8a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        #custom-question-submit:hover {
            background: #1e40af;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        #custom-question-submit:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(30, 58, 138, 0.3);
            border-radius: 50%;
            border-top-color: #1e3a8a;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .instruction {
            opacity: 0.8;
            font-size: 14px;
            margin-top: 10px;
        }
        
        #interaction-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            font-size: 14px;
        }
        
        .floating-text {
            position: absolute;
            color: #1e3a8a;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <h2>‚öñÔ∏è Legal Tech Consulting Team Office</h2>
        <p style="font-size: 18px;">üíº Interactive FAQ Hub</p>
        <p>Use WASD to move around</p>
        <p>Arrow keys or mouse to look left/right</p>
        <p>Press E to interact</p>
        <p>Press SPACE to dance</p>
        <p>Press ESC to close dialogs/release mouse</p>
        <p class="instruction" style="margin-top: 10px;">üí° Ask anything about legal tech!</p>
    </div>
    
    <div id="dialogue-box">
        <h3 id="dialogue-name">Name</h3>
        <div id="dialogue-content">Content</div>
        <div id="dialogue-options"></div>
        <div id="custom-question-container">
            <p style="margin: 5px 0; font-size: 14px; opacity: 0.8; text-align: center;">‚îÅ‚îÅ‚îÅ Or ask your own question ‚îÅ‚îÅ‚îÅ</p>
            <input type="text" id="custom-question-input" placeholder="Ask anything! e.g., 'How do I automate contract review?' or 'What's the best legal tech tool?'" maxlength="200">
            <button id="custom-question-submit">Ask Question</button>
        </div>
    </div>
    
    <div id="interaction-prompt"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        scene.fog = new THREE.Fog(0xf5f5f5, 10, 50);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Floating text effect
        function createFloatingText(text, worldPos) {
            const screenPos = worldPos.clone();
            screenPos.project(camera);
            
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
            
            const div = document.createElement('div');
            div.className = 'floating-text';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);
            
            setTimeout(() => div.remove(), 2000);
        }
        
        // üß† Typing effect for character dialogue
        async function typeText(element, text, delay = 20) {
        element.innerHTML = ""; // Clear old text
        for (let i = 0; i < text.length; i++) {
            element.innerHTML += text.charAt(i);
            await new Promise(resolve => setTimeout(resolve, delay));
            element.scrollTop = element.scrollHeight; // Keep scroll at bottom
            }
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Floor
        const floorGeometry = new THREE.PlaneGeometry(40, 40);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xdcdcdc,
            roughness: 0.7,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Floor tiles
        const tileGeometry = new THREE.PlaneGeometry(2, 2);
        const tileMaterial1 = new THREE.MeshStandardMaterial({ color: 0xe8e8e8 });
        const tileMaterial2 = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });
        
        for (let x = -20; x < 20; x += 2) {
            for (let z = -20; z < 20; z += 2) {
                const tile = new THREE.Mesh(tileGeometry, ((x + z) / 2) % 2 === 0 ? tileMaterial1 : tileMaterial2);
                tile.position.set(x + 1, 0.01, z + 1);
                tile.rotation.x = -Math.PI / 2;
                tile.receiveShadow = true;
                scene.add(tile);
            }
        }
        
        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf8f8f8,
            roughness: 0.9
        });
        
        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.5
        });
        
        // Back wall with windows
        const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        backWall.position.set(0, 5, -20);
        backWall.receiveShadow = true;
        scene.add(backWall);
        
        for (let x = -15; x <= 15; x += 10) {
            const window = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 3),
                windowMaterial
            );
            window.position.set(x, 5, -19.9);
            scene.add(window);
        }
        
        // Side walls
        const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        leftWall.position.set(-20, 5, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);
        
        const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        rightWall.position.set(20, 5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);
        
        // Office furniture
        const woodMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b6914,
            roughness: 0.6,
            metalness: 0.1
        });
        
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.3,
            metalness: 0.8
        });
        
        // Create desks
        function createDesk(x, z) {
            const deskGroup = new THREE.Group();
            
            const deskTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 1.5),
                woodMaterial
            );
            deskTop.position.y = 0.75;
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            deskGroup.add(deskTop);
            
            const frameGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
            const framePositions = [
                [-1.45, 0.35, -0.7],
                [1.45, 0.35, -0.7],
                [-1.45, 0.35, 0.7],
                [1.45, 0.35, 0.7]
            ];
            
            framePositions.forEach(pos => {
                const frame = new THREE.Mesh(frameGeometry, metalMaterial);
                frame.position.set(...pos);
                frame.castShadow = true;
                deskGroup.add(frame);
            });
            
            const monitorBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
                metalMaterial
            );
            monitorBase.position.set(0, 0.82, 0);
            deskGroup.add(monitorBase);
            
            const monitorStand = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.3, 0.05),
                metalMaterial
            );
            monitorStand.position.set(0, 0.95, 0);
            deskGroup.add(monitorStand);
            
            const monitorScreen = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.7, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 })
            );
            monitorScreen.position.set(0, 1.3, 0);
            deskGroup.add(monitorScreen);
            
            const keyboard = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.02, 0.15),
                metalMaterial
            );
            keyboard.position.set(0, 0.81, 0.3);
            deskGroup.add(keyboard);
            
            const chairSeat = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.05, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairSeat.position.set(0, 0.5, 0.8);
            deskGroup.add(chairSeat);
            
            const chairBack = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.6, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairBack.position.set(0, 0.8, 1.02);
            deskGroup.add(chairBack);
            
            if (Math.random() > 0.5) {
                const mug = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0xffffff })
                );
                mug.position.set(Math.random() * 0.5 - 0.25, 0.85, Math.random() * 0.3);
                deskGroup.add(mug);
            }
            
            deskGroup.position.set(x, 0, z);
            return deskGroup;
        }
        
        // Add desks
        const desk1 = createDesk(-10, -10);
        const desk2 = createDesk(0, -10);
        const desk3 = createDesk(10, -10);
        const desk4 = createDesk(-10, 5);
        const desk5 = createDesk(0, 5);
        const desk6 = createDesk(10, 5);
        scene.add(desk1, desk2, desk3, desk4, desk5, desk6);
        
        // Whiteboard
        const whiteboard = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 0.1),
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.1 })
        );
        whiteboard.position.set(0, 3, -19.8);
        whiteboard.castShadow = true;
        scene.add(whiteboard);
        
        // Roomba
        const roombaGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
        const roombaMaterial = new THREE.MeshStandardMaterial({ color: 0x4169e1 });
        const roomba = new THREE.Mesh(roombaGeometry, roombaMaterial);
        roomba.position.set(5, 0.05, 5);
        roomba.userData = { velocity: new THREE.Vector3(0.05, 0, 0.05) };
        scene.add(roomba);
        
        // Plants
        const plantPot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        plantPot.position.set(-15, 0.2, -15);
        scene.add(plantPot);
        
        const plantLeaves = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 6, 5),
            new THREE.MeshStandardMaterial({ color: 0x228b22 })
        );
        plantLeaves.position.set(-15, 0.8, -15);
        scene.add(plantLeaves);
        
        const plantPot2 = plantPot.clone();
        plantPot2.position.set(15, 0.2, -15);
        scene.add(plantPot2);
        
        const plantLeaves2 = plantLeaves.clone();
        plantLeaves2.position.set(15, 0.8, -15);
        scene.add(plantLeaves2);
        
        // Coffee station
        const coffeeTable = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.8, 1),
            woodMaterial
        );
        coffeeTable.position.set(-18, 0.4, 10);
        coffeeTable.castShadow = true;
        scene.add(coffeeTable);
        
        const coffeeMachine = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.5, 0.3),
            metalMaterial
        );
        coffeeMachine.position.set(-18, 1.05, 10);
        scene.add(coffeeMachine);
        
        // Character creation
        const characters = [];
        
        function createCharacter(name, role, x, z, shirtColor, characterData) {
            const group = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.8, 8);
            const torsoMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 0.6;
            torso.castShadow = true;
            group.add(torso);
            
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
            const armMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.3, 0.7, 0);
            leftArm.rotation.z = Math.PI / 8;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.3, 0.7, 0);
            rightArm.rotation.z = -Math.PI / 8;
            group.add(rightArm);
            
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.4, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.4, 0);
            group.add(rightLeg);
            
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.25;
            head.castShadow = true;
            group.add(head);
            
            const hairGeometry = new THREE.SphereGeometry(0.27, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: characterData.hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.35;
            hair.scale.y = 0.6;
            group.add(hair);
            
            const eyeGeometry = new THREE.SphereGeometry(0.03, 4, 4);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.25, 0.22);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.25, 0.22);
            group.add(rightEye);
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = 'black';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(name, 128, 25);
            context.font = '16px Arial';
            context.fillStyle = '#666';
            context.fillText(role, 128, 45);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.y = 1.8;
            label.scale.set(2, 0.5, 1);
            group.add(label);
            
            group.position.set(x, 0, z);
            group.userData = { 
                name, 
                role, 
                conversations: [],
                initialPosition: new THREE.Vector3(x, 0, z),
                targetPosition: new THREE.Vector3(x, 0, z),
                moveTimer: 0,
                isDancing: false,
                tripChance: 0.001,
                leftArm: leftArm,
                rightArm: rightArm,
                ...characterData
            };
            
            characters.push(group);
            return group;
        }
        
        // Create baby character (smaller)
        function createBaby(name, x, z) {
            const group = new THREE.Group();
            
            const bodyGeometry = new THREE.SphereGeometry(0.2, 8, 6);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffc0cb });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.3;
            body.castShadow = true;
            group.add(body);
            
            const headGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.5;
            head.castShadow = true;
            group.add(head);
            
            const hairGeometry = new THREE.SphereGeometry(0.16, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 0.55;
            hair.scale.y = 0.5;
            group.add(hair);
            
            const eyeGeometry = new THREE.SphereGeometry(0.02, 4, 4);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.05, 0.5, 0.13);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.05, 0.5, 0.13);
            group.add(rightEye);
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = 'black';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(name + ' üë∂', 128, 35);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.y = 0.8;
            label.scale.set(1.5, 0.4, 1);
            group.add(label);
            
            group.position.set(x, 0, z);
            group.userData = { 
                name, 
                role: "Sophie's baby",
                conversations: [],
                initialPosition: new THREE.Vector3(x, 0, z),
                targetPosition: new THREE.Vector3(x, 0, z),
                moveTimer: 0,
                isDancing: false,
                isBaby: true,
                tripChance: 0,
                personality: 'adorable and curious',
                quirk: 'has the best perspective on legal tech',
                hairColor: 0x8b4513
            };
            
            characters.push(group);
            return group;
        }
        
        // Create legal tech team
        const sophie = createCharacter('Sophie Jackson', 'Head of Legal Tech Consulting', -10, -5, 0x9370db, {
            hairColor: 0x4b0082,
            personality: 'visionary and strategic pun enthusiast',
            quirk: 'makes puns at every opportunity and always references the "North star" when discussing strategy'
        });
        
        const laura = createCharacter('Laura Sanders', 'Senior Manager', 10, -5, 0x4169e1, {
            hairColor: 0x8b4513,
            personality: 'organized and solution-focused Swiftie',
            quirk: 'references Taylor Swift songs while explaining legal tech workflows'
        });
        
        const tina = createCharacter('Tina Lepomme', 'Senior Legal Technologist', -10, 5, 0x228b22, {
            hairColor: 0xffeb3b,
            personality: 'analytical and concise',
            quirk: 'always ends her responses with "thanks." as her signature sign-off. Will provide the occasional Star Wars reference'
        });
        
        const jodie = createCharacter('Jodie Pickering', 'Senior Legal Technologist', 10, 5, 0xff6347, {
            hairColor: 0xd2691e,
            personality: 'innovative and thrill-seeking',
            quirk: 'approaches legal tech challenges like extreme sports - the riskier the implementation, the more excited she gets. Yet still being risk conscious and risk aware at the same time.'
        });
        
        const esther = createCharacter('Esther Ng', 'Legal Technologist', -5, 0, 0xffa500, {
            hairColor: 0x000000,
            personality: 'curious and thorough',
            quirk: 'always finds the edge case that breaks the system (in a good way)'
        });
        
        const sajj = createCharacter('Sajj Haider', 'Legal Technologist', 5, 0, 0x20b2aa, {
            hairColor: 0xf0f0f0,
            personality: 'pragmatic and caffeine-powered',
            quirk: 'balances dry humour and internet meme references with genuinely helpful advice; often frames complex legal tech issues as memes before explaining them seriously'
        });
        
        const baby = createBaby('Baby', 0, -15);
        
        scene.add(sophie, laura, tina, jodie, esther, sajj, baby);
        
        // Get references to input elements
        const customQuestionInput = document.getElementById('custom-question-input');
        const customQuestionSubmit = document.getElementById('custom-question-submit');
        
        // Player controls
        const player = {
            position: new THREE.Vector3(0, 1.6, 5),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.1,
            isDancing: false
        };
        
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            if (document.activeElement === customQuestionInput) {
                if (e.key === 'Escape') {
                    dialogueBox.style.display = 'none';
                    currentCharacter = null;
                    if (document.pointerLockElement === renderer.domElement) {
                        document.exitPointerLock();
                    }
                }
                return;
            }
            
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            
            if (e.key.toLowerCase() === 'e' && nearbyCharacter && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                openDialogue(nearbyCharacter);
            }
            
            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                player.isDancing = true;
                createFloatingText('üíÉüï∫', player.position);
            }
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (document.activeElement === customQuestionInput) {
                return;
            }
            
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
            
            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                player.isDancing = false;
            }
        });
        
        // Character movement AI
        function updateCharacterMovement(character, deltaTime) {
            if (character.userData.isBaby) {
                // Baby just sits there looking cute and occasionally wiggles
                character.position.y = Math.abs(Math.sin(Date.now() * 0.003)) * 0.05;
                character.rotation.y += 0.01;
                return;
            }
            
            if (Math.random() < character.userData.tripChance && !character.userData.isDancing) {
                character.rotation.x = Math.PI / 4;
                character.position.y = 0.3;
                createFloatingText('Oof!', character.position);
                
                setTimeout(() => {
                    character.rotation.x = 0;
                    character.position.y = 0;
                }, 1000);
                
                character.userData.tripChance = 0;
                setTimeout(() => {
                    character.userData.tripChance = 0.001;
                }, 5000);
            }
            
            if (character === currentCharacter || character.userData.isDancing) {
                if (character === currentCharacter) {
                    const lookTarget = new THREE.Vector3(player.position.x, character.position.y, player.position.z);
                    character.lookAt(lookTarget);
                    character.rotation.x = 0;
                    character.rotation.z = 0;
                }
                return;
            }
            
            if (Math.random() < 0.001) {
                character.userData.isDancing = true;
                createFloatingText('üéµ', character.position);
                setTimeout(() => {
                    character.userData.isDancing = false;
                }, 3000);
            }
            
            character.userData.moveTimer -= deltaTime;
            
            if (character.userData.moveTimer <= 0) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 3 + Math.random() * 5;
                character.userData.targetPosition = new THREE.Vector3(
                    character.userData.initialPosition.x + Math.cos(angle) * distance,
                    0,
                    character.userData.initialPosition.z + Math.sin(angle) * distance
                );
                
                character.userData.targetPosition.x = Math.max(-18, Math.min(18, character.userData.targetPosition.x));
                character.userData.targetPosition.z = Math.max(-18, Math.min(18, character.userData.targetPosition.z));
                
                character.userData.moveTimer = 5 + Math.random() * 5;
            }
            
            const direction = new THREE.Vector3().subVectors(character.userData.targetPosition, character.position);
            direction.y = 0;
            const distance = direction.length();
            
            if (distance > 0.1) {
                direction.normalize();
                character.position.add(direction.multiplyScalar(0.02));
                
                character.lookAt(character.userData.targetPosition);
                character.rotation.x = 0;
                character.rotation.z = 0;
                
                if (!character.userData.isDancing) {
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
                }
            }
        }
        
        // Dialogue system
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueName = document.getElementById('dialogue-name');
        const dialogueContent = document.getElementById('dialogue-content');
        const dialogueOptions = document.getElementById('dialogue-options');
        const interactionPrompt = document.getElementById('interaction-prompt');
        
        let currentCharacter = null;
        let nearbyCharacter = null;
        
        function generateDialogueOptions(character) {
            if (character.userData.isBaby) {
                return [
                    'What do you think about legal tech?',
                    'Do you like document automation?',
                    'What\'s your favorite legal tech tool?',
                    'Can you teach me about AI?'
                ];
            }
            
            const allQuestions = [
                // Getting started
                'How do I get started with legal tech?',
                'What tools does your team use most?',
                'How can I automate my legal workflows?',
                'What\'s the best way to learn legal technology?',
                
                // Contract & document management
                'How do you handle contract automation?',
                'What\'s your approach to document review?',
                'Can AI really review contracts effectively?',
                'How do you manage legal documents at scale?',
                
                // Technical questions
                'What\'s the most challenging legal tech problem you\'ve solved?',
                'How do you integrate legal tech with existing systems?',
                'What coding skills are useful for legal technologists?',
                'How do you handle data security in legal tech?',
                
                // AI & automation
                'How is AI changing legal work?',
                'What can legal AI actually do vs. what can\'t it do?',
                'Should lawyers be worried about AI replacing them?',
                'How do you train lawyers to use AI tools?',
                
                // About the role
                'What\'s a typical day like for you?',
                'What made you interested in legal technology?',
                'What\'s the most rewarding part of your job?',
                'What skills do you need to be a legal technologist?',
                
                // Implementation & strategy
                'How do you convince lawyers to adopt new technology?',
                'What\'s your process for implementing new tools?',
                'How do you measure ROI on legal tech investments?',
                'What are the biggest barriers to legal tech adoption?',
                
                // Fun questions
                'What\'s the funniest tech mishap you\'ve seen?',
                'Do you dream in code or legal clauses?',
                'What\'s your favorite legal tech innovation?',
                'If you could automate one annoying legal task, what would it be?',
                
                // Practical advice
                'What legal tech tools should every lawyer know?',
                'How do you stay current with legal technology trends?',
                'What mistakes should legal tech newbies avoid?',
                'What\'s your favorite productivity hack?',
                
                // Future of legal tech
                'Where is legal technology heading?',
                'What emerging tech excites you most?',
                'Will all legal work be automated eventually?',
                'What\'s the next big thing in legal tech?'
            ];
            
            const shuffled = allQuestions.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 4);
        }
        
        function openDialogue(character) {
            currentCharacter = character;
            dialogueBox.style.display = 'block';
            dialogueName.textContent = `${character.userData.name} - ${character.userData.role}`;
            
            if (document.pointerLockElement === renderer.domElement) {
                document.exitPointerLock();
            }
            
            if (character.userData.isBaby) {
                const babyGreetings = [
                    'Goo goo ga ga! *reaches for your phone* üì±',
                    'Baba! *points at computer screen excitedly*',
                    '*giggles and drools on important legal documents*',
                    'Da da! *accidentally closes all your browser tabs*'
                ];
                dialogueContent.innerHTML = `<p><strong>${character.userData.name}:</strong> ${babyGreetings[Math.floor(Math.random() * babyGreetings.length)]}</p>`;
            } else {
                const greetings = [
                    `Hi! I'm ${character.userData.name}, ${character.userData.role}. Happy to answer any questions about legal tech!`,
                    `Hello! ${character.userData.name} here. I ${character.userData.quirk}. What would you like to know?`,
                    `Hey there! I'm ${character.userData.name}. Ask me anything about legal technology!`,
                    `Great timing! I'm ${character.userData.name}. How can I help you with legal tech today?`
                ];
                
                if (character.userData.conversations.length === 0) {
                    dialogueContent.innerHTML = `<p><strong>${character.userData.name}:</strong> ${greetings[Math.floor(Math.random() * greetings.length)]}</p>`;
                } else {
                    const lastConv = character.userData.conversations[character.userData.conversations.length - 1];
                    dialogueContent.innerHTML = `<p><strong>You:</strong> ${lastConv.user}</p><p><strong>${character.userData.name}:</strong> ${lastConv.response}</p>`;
                }
            }
            
            const options = generateDialogueOptions(character);
            dialogueOptions.innerHTML = '';
            
            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'dialogue-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectOption(option);
                dialogueOptions.appendChild(optionDiv);
            });
            
            document.getElementById('custom-question-input').value = '';
            
            setTimeout(() => {
                document.getElementById('custom-question-input').focus();
            }, 100);
        }
        
        async function selectOption(option) {
    if (!currentCharacter) return;
    
    dialogueContent.innerHTML += `<p><strong>You:</strong> ${option}</p>`;
    dialogueContent.innerHTML += `<p><strong>${currentCharacter.userData.name}:</strong> <span class="loading"></span></p>`;
    
    dialogueContent.scrollTop = dialogueContent.scrollHeight;
    
    const customQuestionInput = document.getElementById('custom-question-input');
    const customQuestionSubmit = document.getElementById('custom-question-submit');
    
    dialogueOptions.style.pointerEvents = 'none';
    dialogueOptions.style.opacity = '0.5';
    customQuestionInput.disabled = true;
    customQuestionSubmit.disabled = true;
    
    let responseText = "";
    
    try {
        // Call your Hugging Face Space API
        const response = await fetch("https://esth21-LTCSimulator.hf.space/chat", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                user_message: option,
                character: {
                    name: currentCharacter.userData.name,
                    role: currentCharacter.userData.role,
                    personality: currentCharacter.userData.personality,
                    quirk: currentCharacter.userData.quirk,
                    isBaby: currentCharacter.userData.isBaby || false
                }
            }),
        });

if (response.ok) {
    const data = await response.json();
    responseText = data.response || "Hmm... that's one I'll need to check and 'circle back' on!";
    console.log('‚úÖ Using AI-generated response from Hugging Face Space');
} else {
    console.warn('‚ö†Ô∏è API returned error status:', response.status);
    throw new Error('API returned error');
}

    } catch (error) {
        console.error('‚ùå API Error:', error);
        console.log('üìù Using enhanced fallback response');
        responseText = generateFallbackResponse(currentCharacter, option);
    }
    
    currentCharacter.userData.conversations.push({
        user: option,
        response: responseText
    });
    
    const loadingSpan = dialogueContent.querySelector(".loading");
if (loadingSpan) {
    const container = document.createElement("span");
    loadingSpan.replaceWith(container);
    await typeText(container, responseText, 20); // Typing speed (ms per char)
}
    
    dialogueContent.scrollTop = dialogueContent.scrollHeight;
    
    if (Math.random() < 0.2) {
        createFloatingText('üí°', currentCharacter.position);
    }
    
    const newOptions = generateDialogueOptions(currentCharacter);
    dialogueOptions.innerHTML = '';
    
    newOptions.forEach(opt => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'dialogue-option';
        optionDiv.textContent = opt;
        optionDiv.onclick = () => selectOption(opt);
        dialogueOptions.appendChild(optionDiv);
    });
    
    dialogueOptions.style.pointerEvents = 'auto';
    dialogueOptions.style.opacity = '1';
    customQuestionInput.disabled = false;
    customQuestionSubmit.disabled = false;
    customQuestionInput.focus();
}
        
        function generateFallbackResponse(character, question) {
            if (character.userData.isBaby) {
                const babyResponses = [
                    'Goo goo! *presses random keys on keyboard* üë∂üíª',
                    'Babababa! *chews on mouse cable* üê≠',
                    '*giggles and accidentally deletes important files* Oopsie!',
                    'Da! *points at screen* Pretty colors! ‚ú®',
                    '*drools on server room access card* Yummy!',
                    'Waaah! *needs nap after too much talk about APIs* üò¥'
                ];
                return babyResponses[Math.floor(Math.random() * babyResponses.length)];
            }
            
            const responses = {
                'Sophie Jackson': [
                    'As Head of Legal Tech Consulting, our North star is building bridges between legal expertise and tech innovation. You could say we\'re "bridging" the gap! Get it?',
                    'The future of legal tech? Our North star points to augmentation, not replacement. We\'re not trying to "replace" anyone - we want to give them some "space"! üòÑ',
                    'My biggest tip? Keep your North star visible - start small, prove value, then scale. Otherwise you\'re just "shooting for the stars" without a telescope!',
                    'Legal tech consulting needs a clear North star. Think ahead, adapt when needed. It\'s like chess, except the stakes are higher and the puns are worse! We\'re really "checking" all the boxes here.'
                ],
                'Laura Sanders': [
                    'You know what Taylor Swift says - we should "Shake It Off" when tech implementations don\'t go perfectly! Learn, iterate, and move forward.',
                    'As Senior Manager, I organize our tech strategy like a setlist - every tool needs to be in the right order to create the perfect workflow. It\'s our "Love Story" with legal tech!',
                    'My philosophy? "Begin again" with every project. Fresh eyes, Swiftie enthusiasm, and methodical planning. Also, everything gets a Taylor Swift-themed project name.',
                    'When lawyers resist new tech, I remind them: "The old ways won\'t open new doors." We\'re writing our own success story, one automation at a time! üéµ'
                ],
                'Tina Lepomme': [
                    'Let me break this down: identify the problem, analyze root causes, implement solution, test thoroughly. Edge cases are where systems break, so we focus on comprehensive testing before deployment. Documentation is critical throughout. Thanks.',
                    'The key with legal tech is attention to detail. We test everything systematically before rollout. Debugging requires thinking like both a developer and a lawyer simultaneously - it\'s methodical work that pays off. Thanks.',
                    'My approach is systematic: structured analysis, clear documentation, comprehensive testing. This process keeps things running smoothly and helps us catch issues before they become problems. Thanks.',
                    'Legal tech debugging is fascinating work. You need to understand both technical architecture and legal workflows. When you combine those perspectives, solutions become much clearer and more robust. Thanks.'
                ],
                'Jodie Pickering': [
                    'This implementation? It\'s like BASE jumping - thrilling, requires preparation, and when it works perfectly, it\'s absolutely exhilarating!',
                    'I love high-stakes legal tech projects! Rolling out new AI tools is like white-water rafting - navigate carefully, embrace the chaos, and enjoy the ride!',
                    'User adoption is my favorite extreme sport. The challenge of getting 100+ lawyers on board? That\'s my Everest, and I\'m here for it!',
                    'Why play it safe? The most innovative legal tech solutions come from taking calculated risks. It\'s like skydiving - terrifying and amazing!'
                ],
                'Esther Ng': [
                    'Oh, I found an edge case with that just last week! Let me tell you what happened...',
                    'Testing is my specialty. If there\'s a way for something to break, I\'ll find it - which makes our systems more robust in the long run!',
                    'Curiosity drives good legal tech. I\'m always asking "what if?" and "have we considered?" Those questions prevent problems later.',
                    'The most interesting bugs are the ones nobody expected. That\'s where you learn the most about how systems actually work versus how you think they work!'
                ],
                'Sajj Haider': [
                    'Legal tech problems? Easy. Step 1: turn it into a meme. Step 2: fix it. Step 3: sip coffee while pretending it was easy. ‚òï',
                    'Honestly, automation isn‚Äôt just about saving time‚Äîit‚Äôs about saving brain cells for when you actually need to think. Meme it, automate it, move on.',
                    'Picture your workflow as a meme template: we identify the punchline (the inefficiency), then redesign it so the joke lands every time.','The secret? Marry practicality with humour. I use memes to make lawyers laugh *and* understand why process automation matters. Keeps everyone awake‚Äîno espresso required (okay, maybe one).'
                ]
            };
            
            const characterResponses = responses[character.userData.name] || [
                'That\'s a great question about legal technology! We\'re always working to make legal workflows more efficient and effective.',
                'In legal tech, we balance innovation with practicality. Every solution needs to work in the real world, not just in theory.',
                'The exciting thing about this field is how rapidly it\'s evolving. What seemed impossible five years ago is routine now!',
                'My advice? Stay curious, keep learning, and always ask how technology can serve legal professionals better.'
            ];
            
            return characterResponses[Math.floor(Math.random() * characterResponses.length)];
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                dialogueBox.style.display = 'none';
                currentCharacter = null;
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
            }
        });
        
        customQuestionSubmit.addEventListener('click', () => {
            const customQuestion = customQuestionInput.value.trim();
            if (customQuestion && currentCharacter) {
                selectOption(customQuestion);
                customQuestionInput.value = '';
            }
        });
        
        customQuestionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const customQuestion = customQuestionInput.value.trim();
                if (customQuestion && currentCharacter) {
                    selectOption(customQuestion);
                    customQuestionInput.value = '';
                }
            }
        });
        
        // Animation loop
        let lastTime = 0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            player.velocity.set(0, 0, 0);
            
            if (!player.isDancing && dialogueBox.style.display !== 'block') {
                if (keys['w']) player.velocity.z = player.speed;
                if (keys['s']) player.velocity.z = -player.speed;
                if (keys['a']) player.velocity.x = -player.speed;
                if (keys['d']) player.velocity.x = player.speed;
            }
            
            const lookSpeed = 0.05;
            if (dialogueBox.style.display !== 'block') {
                if (keys['ArrowLeft']) {
                    mouseX += lookSpeed;
                }
                if (keys['ArrowRight']) {
                    mouseX -= lookSpeed;
                }
            }
            
            if (!player.isDancing && dialogueBox.style.display !== 'block') {
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
            }
            
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();
            
            player.position.add(forward.multiplyScalar(player.velocity.z));
            player.position.add(right.multiplyScalar(player.velocity.x));
            
            player.position.x = Math.max(-18, Math.min(18, player.position.x));
            player.position.z = Math.max(-18, Math.min(18, player.position.z));
            
            if (player.isDancing && dialogueBox.style.display !== 'block') {
                camera.position.y = player.position.y + Math.sin(Date.now() * 0.01) * 0.2;
                camera.rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
            } else {
                camera.position.copy(player.position);
                camera.rotation.z = 0;
                if (dialogueBox.style.display !== 'block') {
                    camera.rotation.y = mouseX;
                    camera.rotation.x = 0;
                }
            }
            
            characters.forEach(character => {
                updateCharacterMovement(character, deltaTime);
                
                if (character.userData.isDancing && !character.userData.isBaby) {
                    character.rotation.y += 0.1;
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.3;
                    
                    character.userData.leftArm.rotation.z = Math.sin(Date.now() * 0.01) * 0.5 + Math.PI / 8;
                    character.userData.rightArm.rotation.z = -Math.sin(Date.now() * 0.01) * 0.5 - Math.PI / 8;
                }
            });
            
            roomba.rotation.y += 0.05;
            roomba.position.add(roomba.userData.velocity);
            
            if (Math.abs(roomba.position.x) > 18 || Math.abs(roomba.position.z) > 18) {
                roomba.userData.velocity.multiplyScalar(-1);
                createFloatingText('Bonk!', roomba.position);
            }
            
            nearbyCharacter = null;
            let minDistance = Infinity;
            
            characters.forEach(character => {
                const distance = player.position.distanceTo(character.position);
                if (distance < 3 && distance < minDistance) {
                    minDistance = distance;
                    nearbyCharacter = character;
                }
            });
            
            if (nearbyCharacter && !currentCharacter) {
                interactionPrompt.style.display = 'block';
                interactionPrompt.textContent = `Press E to talk to ${nearbyCharacter.userData.name}`;
            } else {
                interactionPrompt.style.display = 'none';
            }
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement && dialogueBox.style.display !== 'block') {
                mouseX += e.movementX * 0.002;
            }
        });
        
        renderer.domElement.addEventListener('click', () => {
            if (!dialogueBox.style.display || dialogueBox.style.display === 'none') {
                renderer.domElement.requestPointerLock();
            }
        });
        
        animate(0);
    </script>
</body>
</html>
